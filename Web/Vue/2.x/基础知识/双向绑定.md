# vue2.x 双向绑定

## 原理

`Vue` 内部通过 `Object.defineProperty()` 方法来拦截对象属性，将 `data` 对象里的每个数据的读写转化成 `getter/setter` 。此方法具体可[参考笔记](../../../../编程语言/JavaScript/基础语法/对象/defineProperty.md)

## 设计方案

我们要实现的东西就是 `MVVM` 架构中的 `ViewModel（视图模型）` 与 `View（页面）` 之间的通信，相关内容移步：[MVVM架构](../../../../程序设计/架构思想/MVVM/README.md)

架构图中已经画出了双向绑定的技术架构，要实现双向绑定，需要利用到一个成熟的设计模式——[观察者设计模式](../../../../程序设计/设计模式/行为型模式/观察者模式/README.md)，当然，我们这里使用的是[JavaScript版观察者设计模式](../../../../编程语言/JavaScript/设计模式/常用设计模式/观察者模式/README.md)

### 实现过程

首先，我们要对数据进行劫持监听，所以需要一个 `Observer（监听器` ），用来监听所有属性。如果发现属性变化了，就告诉 `Watcher（订阅者）` ， `Watcher` 来决定是否需要更新视图。

在这个基础上我们进行优化，因为订阅者有很多个，一个一个的管理会浪费大量的精力，所以我们需要一个 `“容器”（Dep）` 来专门维护和管理这些 `Observer` 和 `Watcher` 。（题外话，这里的设计很像[Ioc](../../../../程序设计/架构思想/Ioc/README.md))。

除此之外，我们还需要一个 `Compile(指令解析器)` ，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个 `Watcher` ，并替换模板数据或者绑定相应的函数。此时，当 `Watcher` 收到相应属性的变化，就会执行对应的更新函数，从而更新视图。

架构图如下：

``` mermaid
graph LR;
    A["Observer(劫持并监听所有属性)"] -- 通知变化 --> B[Dep];
    B -- 通知变化 --> C[Watcher];
    C -- 添加 --> B;
    C -- 更新 --> D[View];
    D -- 初始化 --> E["Compile(编译解析)"];
    E -- 绑定更新函数 --> C;
```

### Observer
