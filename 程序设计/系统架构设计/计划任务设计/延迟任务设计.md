# 延迟任务设计

## 需求背景

很多系统一般都会遇到延迟任务设计，例如商城系统的订单自动关闭功能：下单之后30s没有操作就自动关闭订单。

## 方案评估

`方案没有最好，只有最合适的` ，例如对于数据一致性要求不高的场景（物联网的一些记录），那是可以忍受一些脏数据的，这个时候就没有必要为了数据一致性花费大量的时间。但是对于商城的订单系统，一点脏数据都不可以有，账单差一分钱都不行！这个时候数据一致性才是方案选择首要考虑的。

最简单的 `SetTimeout()` 方法就能实现延迟任务的需求，那么为什么很少用呢？原因之一在于 `健壮性太弱了` 。在发起延迟任务到延迟任务执行期间，如果系统遇到一些意外因素导致系统重启了，那这个任务就相当于丢了！对于钱财相关的程序，这是不可忍受的！所以，在方案设计的时候， `保证任务一定会执行到` 是一个很重要的评估标准。所以很少有系统直接使用 `setTimeout()` 方法来实现延迟任务。

为了保证任务一定会执行到，通常有两种方式，一种是 `持久化` ，一种是 `消息队列` 。

### 持久化

将任务持久化到本地，例如存到 `MySQL` 的一个表中，这个表记录要执行的任务，到时候按时来取，之后进行任务的执行，执行完成后更新表中的信息。

### 消息队列

消息队列天然实现了 `消息必达功能` （题外话：这里面可能出现消息积压等问题，本篇不是主要将消息队列的，因此不做过多赘述，有兴趣的可以看一下[消息中间件篇](../../../消息中间件/README.md)）。这个功能可以保证程序的消费者一定会接收到通知。这里面要考虑的是：虽然我们接受了，结果我们在处理中失败了，那么要如何处理？将任务丢回消息队列吗？(并不是所有消息中间件都支持丢回功能)如果处理不好，日志系统不健全，很容易出现诡异的任务丢失情况。

**总结**

个人更喜欢将任务持久化，因为数据库基本上项目都有，引入消息队列可能会增加系统复杂度，耦合度也会大大增加。

## 持久化方案设计

首先在系统启动的时候开启一个计划任务， `1s` 执行一次，查询数据中延迟任务的表，将需要执行的任务取出来，之后开始执行，执行完成之后更新数据库中的任务，或者直接删掉这个任务（如果加上任务的执行记录的话，建议直接删除）。

这种方案需要注意的地方：

* **计划任务执行间隔**

如果选择了1s作为计划任务执行间隔，如果系统量级比较大，在这1s内需要执行的任务过多，1s没有执行完成，那么就会影响下一秒的任务执行（虽然通过事物可以避免重复执行问题，但是会造成任务积压，搞不好内存溢出崩了），这个时候可以考虑适当增加任务执行间隔，如果不想增加执行间隔，请往下看。

* **并发执行**

  
在数据库中将任务列表取出来后如何执行？很容易想到 `for of` 方法依次执行。（题外话：任务的执行必须使用事物，事物可以[参考笔记](../../../数据库/SQL/事物.md)）或者更有想法的可能会想到使用 `Promise.allSettled()` 来并发执行。（这里为啥不使用 `Promise.all()` 呢？自行考虑，笔记还没来的总结。。。）这里使用并发执行实际上不好，会造成 `瞬时系统压力过大` ，产生 `脉冲` 现象。

那如何执行更优雅呢？答案是 `借助数据库的流` 。

很多情况我们查询数据库获取一个集合到代码中进行处理，也就是处理数组，这个时候数据库中符合查询条件的数据都已经实例化到代码中了（很多情况查询都会带有分页支持，就是为了避免查询数据量过大的情况），这个场景分页也行，但是不够优雅，还会增加很多代码量。借助数据库的流方法可以很优雅的处理这个问题，拿到查询结果 `Stream` ，可以当成 `指针` （实际上就是指针，但不是C语言的指针哦！），然后我们可以控制多少个任务一起执行，执行完继续执行下一组。打个比方：拿到指针后，先执行5个，执行完后继续执行5个，一直到执行完成（具体执行几个考虑服务器性能和任务复杂度）。

解决一下上面遗留的问题，如果在时间间隔中没有执行完成怎么办？

这里需要引入 `锁` 的思想，在计划任务开始执行的时候先去获取锁（单机版这里就很简单了，直接定义一个bool类型的变量就行了），拿到之后再开始执行，当执行完成之后释放锁。

## 多开解决方案

很多部署都会涉及到多开部署（因为nodejs的 `单主线程` 嘛），一般会有pm2, docker, k8s等方案。多开的时候，计划任务需要做特殊支持，如果不做支持，那很可能会一个任务执行多次！

对于pm2，因为他用的是cluster的模式，主进程控制子进程，在计划任务开启的时候，通过主进程来去控制到底哪个子进程来执行计划任务就可以了，这是做容易做的。

那非cluster模式的呢？这时候就要上 `分布式锁` 了，一般用 `Redis` 来实现分布式锁（笔记还没写）。在应用触发计划任务的时候去获取分布式锁，拿到锁的执行任务，拿不到的就直接 `return` 。
（注意：分布式锁这里道道也比较多，有空补上。）